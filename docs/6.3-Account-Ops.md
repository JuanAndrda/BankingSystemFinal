# Banking System - Account Operations Documentation

**Project:** Banking Management System Final Project
**Courses:** CIT 207 & CC 204
**Document:** Account Operations (Admin #5-9, Customer #1)
**Date:** December 2025

---

## ğŸ“‘ Navigation

**â† Back to:** [Customer Operations](6.2-Customer-Ops.md) | **Up to:** [Menu Overview](6-Menu-Overview.md) | **Next:** [Transaction Operations â†’](6.4-Transaction-Ops.md)

**Menu Documentation Index:**
- [6-Menu-Overview.md](6-Menu-Overview.md) - Architecture and summary tables
- [6.1-Login.md](6.1-Login.md) - Login Screen
- [6.2-Customer-Ops.md](6.2-Customer-Ops.md) - Customer Operations (Admin #1-4)
- **6.3-Account-Ops.md** - â† You are here
- [6.4-Transaction-Ops.md](6.4-Transaction-Ops.md) - Transaction Operations (Admin #10-13, Customer #2-5)
- [6.5-Profile-Reports.md](6.5-Profile-Reports.md) - Profile & Reports (Admin #14-19)
- [6.6-Security-Session.md](6.6-Security-Session.md) - Security & Session (Admin #21, #0, #20)

---

## Overview

This document covers **Account Operations** - 5 menu options for managing bank accounts. These operations demonstrate **polymorphism** (Savings vs Checking accounts) and include one **shared option** accessible to both admins and customers.

### Account Operations Summary

| Admin # | Customer # | Option Name | Handler | Access | Purpose |
|---------|------------|-------------|---------|--------|---------|
| **5** | - | Create Account | `AccountManager.handleCreateAccount()` | Admin Only | Polymorphic account creation (Savings/Checking) |
| **6** | **1** | View Account Details | `AccountManager.handleViewAccountDetails()` | Both (access-controlled) | Display account info with type-specific details |
| **7** | - | View All Accounts | `AccountManager.handleViewAllAccounts()` | Admin Only | List all accounts in table format |
| **8** | - | Delete Account | `AccountManager.handleDeleteAccount()` | Admin Only | Remove account with balance check |
| **9** | - | Update Overdraft Limit | `AccountManager.handleUpdateOverdraftLimit()` | Admin Only | Modify checking account overdraft |

**Category:** ACCOUNT_OPERATIONS
**Shared Option:** View Account Details (#6/#1) - demonstrates access control

---

## [Admin #5] Create Account

### 1. Menu Option Details

| Property | Value |
|----------|-------|
| **Admin Number** | 5 |
| **Customer Number** | N/A (Admin Only) |
| **Category** | ACCOUNT_OPERATIONS |
| **Display Name** | "Create Account" |
| **Handler Method** | `AccountManager.handleCreateAccount()` |
| **Source File** | `src/com/banking/managers/AccountManager.java:438-477` |
| **Access Control** | ADMIN only |
| **Required Permission** | CREATE_ACCOUNT |

### 2. Purpose and Functionality

Creates a new bank account (Savings or Checking) and links it to an existing customer.

**What it does:**
- Prompts for customer ID (validates customer exists)
- Prompts for account type (SAVINGS or CHECKING)
- Auto-generates account number (ACC001, ACC002...)
- **Polymorphic creation:** Creates `SavingsAccount` or `CheckingAccount` based on type
- Links account to customer (one-to-many relationship)
- Adds to `LinkedList<Account>`
- Logs action to audit trail

**Why use this:**
- Customers need accounts to perform transactions
- Demonstrates polymorphism (different account types)
- Shows composition (Customer has Accounts)
- Establishes one-to-many relationship

**Polymorphism:** Same method creates different account types at runtime based on user input.

### 3. Step-by-Step Code Flow

#### Step 1: Menu Selection
User selects option 5 â†’ Routes to `CREATE_ACCOUNT` â†’ Calls `accountMgr.handleCreateAccount()`

#### Step 2: Permission Check
Admin-only option (customerMenuNumber = -1 in MenuAction enum).

#### Step 3: Input Collection - Customer ID & Account Type

**Location:** `AccountManager.java:438-462`

```java
UIFormatter.printSectionHeader("CREATE ACCOUNT");

while (true) {  // RETRY LOOP
    // Get customer
    Customer customer = this.validator.getValidatedCustomer(
        "âœ— Customer not found. Please create customer first (Option 1).");
    if (customer == null) return;

    // Get account type
    String type = this.validator.getValidatedAccountType(
        "Account type (SAVINGS or CHECKING):");
    if (type == null) return;

    // Create account
    Account account = this.createAndDisplayAccount(customer, type);
    if (account != null) {
        break;  // Success
    } else {
        if (!this.validator.confirmAction("Try again?")) return;
    }
}
```

**Account Type Validation:**
```java
public String getValidatedAccountType(String prompt) {
    while (true) {
        String input = getValidatedString(prompt);
        if (input == null) return null;

        String type = input.toUpperCase().trim();
        if (type.equals("SAVINGS") || type.equals("CHECKING")) {
            return type;
        }

        UIFormatter.printError("Invalid account type. Enter SAVINGS or CHECKING.");
    }
}
```

#### Step 4: Business Logic - Polymorphic Account Creation

**Location:** `AccountManager.java:80-114`

```java
public Account createAccount(String customerId, String accountType,
                              String accountNo) {
    Customer customer = this.customerManager.findCustomer(customerId);
    if (customer == null) {
        UIFormatter.printError("Customer not found: " + customerId);
        return null;
    }

    try {
        Account account;

        // POLYMORPHISM: Create different account types at runtime
        if (accountType.equalsIgnoreCase("SAVINGS")) {
            account = new SavingsAccount(accountNo, 0.0, customerId, customer);
            // SavingsAccount has 1.5% interest rate
        } else if (accountType.equalsIgnoreCase("CHECKING")) {
            account = new CheckingAccount(accountNo, 0.0, customerId, customer);
            // CheckingAccount has $500 default overdraft limit
        } else {
            UIFormatter.printError("Invalid account type: " + accountType);
            return null;
        }

        // Add to LinkedList
        this.accountList.add(account);

        // Establish bidirectional relationship (one-to-many)
        customer.addAccount(account);

        // Polymorphic call: getDetails() implemented differently in each subclass
        UIFormatter.printSuccess("Account created: " + account.getDetails());
        return account;

    } catch (IllegalArgumentException e) {
        UIFormatter.printError("Error creating account: " + e.getMessage());
        return null;
    }
}
```

**Polymorphism in Action:**

1. **Compile-time:** Variable type is `Account` (superclass)
2. **Runtime:** Actual object is `SavingsAccount` or `CheckingAccount` (subclass)
3. **Method calls:** `account.getDetails()` calls the subclass implementation

**Class Hierarchy:**
```
Account (abstract)
    â”œâ”€â”€ SavingsAccount (concrete)
    â”‚       â”œâ”€â”€ interestRate = 0.015 (1.5%)
    â”‚       â””â”€â”€ applyInterest() method
    â””â”€â”€ CheckingAccount (concrete)
            â”œâ”€â”€ overdraftLimit = 500.00
            â””â”€â”€ withdraw() with overdraft support
```

#### Step 5: Data Updates - LinkedList Operations

```java
// LinkedList<Account> accountList - Add operation
this.accountList.add(account);  // O(1) - append to end

// LinkedList<Account> in Customer - Add operation
customer.addAccount(account);  // Also O(1)
```

**Bidirectional Relationship Established:**
- `Account` â†’ `Customer` (via `ownerId` and `owner` reference)
- `Customer` â†’ `Account` (via `LinkedList<Account> accounts`)

#### Step 6: Feedback Display

**Location:** `AccountManager.java:116-140`

```java
public Account createAndDisplayAccount(Customer customer, String accountType) {
    // Auto-generate account number
    String accountNo = this.generateNextAccountNumber();

    // Create account
    Account account = this.createAccount(customer.getCustomerId(),
                                         accountType, accountNo);
    if (account != null) {
        UIFormatter.printSuccess(
            "Account successfully created and linked to customer!",
            "Account Number: " + accountNo,
            "Type: " + accountType,
            "Balance: $0.00");

        // Log action
        if (this.bankingSystem != null) {
            this.bankingSystem.logAction("CREATE_ACCOUNT",
                "Account: " + accountNo + " Type: " + accountType +
                " Customer: " + customer.getCustomerId());
        }
    }
    return account;
}
```

#### Step 7: Audit Logging

```java
auditTrail.push(new AuditLog(
    LocalDateTime.now(),
    currentUser.getUsername(),
    currentUser.getUserRole(),
    "CREATE_ACCOUNT",
    "Account: ACC005 Type: SAVINGS Customer: C003"
));
```

### 4. Code Snippets

**MenuAction Enum:**
```java
CREATE_ACCOUNT("Create Account", 5, -1, UserRole.ADMIN, MenuCategory.ACCOUNT_OPERATIONS)
```

**Polymorphic Account Creation:**

**File:** `src/com/banking/managers/AccountManager.java:80-114`

```java
public Account createAccount(String customerId, String accountType, String accountNo) {
    Customer customer = this.customerManager.findCustomer(customerId);
    if (customer == null) return null;

    try {
        Account account;

        // Runtime polymorphism - type determined by user input
        if (accountType.equalsIgnoreCase("SAVINGS")) {
            account = new SavingsAccount(accountNo, 0.0, customerId, customer);
        } else if (accountType.equalsIgnoreCase("CHECKING")) {
            account = new CheckingAccount(accountNo, 0.0, customerId, customer);
        } else {
            return null;
        }

        // Add to system LinkedList
        this.accountList.add(account);

        // Establish bidirectional link
        customer.addAccount(account);

        // Polymorphic call - different implementations
        UIFormatter.printSuccess("Account created: " + account.getDetails());
        return account;

    } catch (IllegalArgumentException e) {
        UIFormatter.printError("Error: " + e.getMessage());
        return null;
    }
}
```

**SavingsAccount Constructor:**
```java
public class SavingsAccount extends Account {
    private static final double INTEREST_RATE = 0.015;  // 1.5%

    public SavingsAccount(String accountNo, double balance,
                          String ownerId, Customer owner) {
        super(accountNo, balance, ownerId, owner);
        this.interestRate = INTEREST_RATE;
    }

    @Override
    public String getDetails() {
        return String.format("[%s] Savings Account | Owner: %s | Balance: $%.2f | Interest: %.2f%%",
            accountNo, ownerId, balance, interestRate * 100);
    }
}
```

**CheckingAccount Constructor:**
```java
public class CheckingAccount extends Account {
    private double overdraftLimit;

    public CheckingAccount(String accountNo, double balance,
                           String ownerId, Customer owner) {
        super(accountNo, balance, ownerId, owner);
        this.overdraftLimit = 500.00;  // Default $500 overdraft
    }

    @Override
    public String getDetails() {
        return String.format("[%s] Checking Account | Owner: %s | Balance: $%.2f | Overdraft: $%.2f",
            accountNo, ownerId, balance, overdraftLimit);
    }
}
```

### 5. Data Flow Diagram

```
User Input (Admin selects option 5)
    â”‚
    â”œâ”€â”€â†’ AccountManager.handleCreateAccount()
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ Get Customer ID
    â”‚         â”‚         â”‚
    â”‚         â”‚         â””â”€â”€â†’ CustomerManager.findCustomer(id)
    â”‚         â”‚                   â”‚
    â”‚         â”‚                   â””â”€â”€â†’ LinkedList<Customer> search - O(n)
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ Get Account Type (SAVINGS or CHECKING)
    â”‚         â”‚         â”‚
    â”‚         â”‚         â””â”€â”€â†’ InputValidator.getValidatedAccountType()
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ Auto-generate Account Number (ACC001, ACC002...)
    â”‚         â”‚         â”‚
    â”‚         â”‚         â””â”€â”€â†’ generateNextAccountNumber()
    â”‚         â”‚
    â”‚         â””â”€â”€â†’ createAccount(customerId, type, accountNo)
    â”‚                   â”‚
    â”‚                   â”œâ”€â”€â†’ POLYMORPHISM: Create account based on type
    â”‚                   â”‚         â”‚
    â”‚                   â”‚         â”œâ”€â”€â†’ if (SAVINGS): new SavingsAccount(...)
    â”‚                   â”‚         â””â”€â”€â†’ if (CHECKING): new CheckingAccount(...)
    â”‚                   â”‚
    â”‚                   â”œâ”€â”€â†’ accountList.add(account)  [LinkedList]
    â”‚                   â”‚
    â”‚                   â””â”€â”€â†’ customer.addAccount(account)
    â”‚                             â”‚
    â”‚                             â””â”€â”€â†’ Bidirectional link established
    â”‚
    â”œâ”€â”€â†’ Log to Stack<AuditLog>
    â”‚
    â””â”€â”€â†’ Display success message with polymorphic getDetails()
```

### 6. Example Usage

**Scenario 1: Create Savings Account**

**Console Input/Output:**
```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CREATE ACCOUNT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â†’ Customer ID: C003
âœ“ Customer found: Alice Johnson

â†’ Account type (SAVINGS or CHECKING): SAVINGS
âœ“ Account number auto-generated: ACC005

âœ“ Account successfully created and linked to customer!
  Account Number: ACC005
  Type: SAVINGS
  Balance: $0.00
```

**Data After:**
```java
accountList (LinkedList):
  SavingsAccount{accountNo='ACC005', balance=0.0, ownerId='C003',
                 interestRate=0.015}

customer C003 (LinkedList<Account>):
  accounts = [ACC003, ACC005]  // Added to customer's account list

auditTrail (Stack):
  AuditLog{action='CREATE_ACCOUNT',
           details='Account: ACC005 Type: SAVINGS Customer: C003'}
```

---

**Scenario 2: Create Checking Account**

**Console Input:**
```
â†’ Customer ID: C004
â†’ Account type (SAVINGS or CHECKING): CHECKING
```

**Console Output:**
```
âœ“ Account number auto-generated: ACC006

âœ“ Account successfully created and linked to customer!
  Account Number: ACC006
  Type: CHECKING
  Balance: $0.00
```

**Data After:**
```java
accountList (LinkedList):
  CheckingAccount{accountNo='ACC006', balance=0.0, ownerId='C004',
                  overdraftLimit=500.0}
```

---

**Scenario 3: Error - Customer Not Found**

**Console Input/Output:**
```
â†’ Customer ID: C999
âœ— Customer not found. Please create customer first (Option 1).
â†’ Try again? (yes/no): no
â„¹ Operation cancelled.
```

---

## [Admin #6 / Customer #1] View Account Details

### 1. Menu Option Details

| Property | Value |
|----------|-------|
| **Admin Number** | 6 |
| **Customer Number** | 1 |
| **Category** | ACCOUNT_OPERATIONS |
| **Display Name** | "View Account Details" |
| **Handler Method** | `AccountManager.handleViewAccountDetails()` |
| **Source File** | `src/com/banking/managers/AccountManager.java:506-549` |
| **Access Control** | Both roles (access-controlled) |
| **Required Permission** | VIEW_ACCOUNT_DETAILS (admin), VIEW_OWN_ACCOUNTS (customer) |

**Dual Numbering Example:**
```java
VIEW_ACCOUNT_DETAILS("View Account Details", 6, 1, null, MenuCategory.ACCOUNT_OPERATIONS)
//                                            â†‘  â†‘  â†‘
//                                       Admin Cust Both
```

### 2. Purpose and Functionality

Displays detailed information about a specific account with **access control** and **polymorphic display**.

**What it does:**
- Prompts for account number
- **Access Control:**
  - Admins: Can view any account
  - Customers: Can only view their own accounts
- Displays account info in professional box format
- Shows type-specific details (interest rate for Savings, overdraft for Checking)
- Demonstrates **runtime polymorphism** (instanceof checks)

**Why use this:**
- Check account balance and details
- View type-specific information
- Demonstrates access control pattern
- Shows polymorphism in action

### 3. Step-by-Step Code Flow

#### Step 1: Menu Selection
- Admin selects #6 â†’ Routes to `VIEW_ACCOUNT_DETAILS`
- Customer selects #1 â†’ Routes to same `VIEW_ACCOUNT_DETAILS`
- **Same handler, different menu numbers!**

#### Step 2: Permission Check

MenuAction allows both roles:
```java
VIEW_ACCOUNT_DETAILS(..., 6, 1, null, ...)
//                              â†‘
//                          null = both roles allowed
```

#### Step 3: Input Collection with Access Control

**Location:** `AccountManager.java:506-511`

```java
UIFormatter.printSectionHeader("VIEW ACCOUNT DETAILS");

// Access-controlled input based on current user role
Account account = this.validator.getValidatedAccountWithAccessControl(
    this.bankingSystem.getCurrentUser());

if (account == null) return;
```

**Access Control Logic:**

**File:** `InputValidator.java`

```java
public Account getValidatedAccountWithAccessControl(User currentUser) {
    while (true) {
        // Get account number
        String accNo = getValidatedInput("Account Number:",
            ValidationPatterns.ACCOUNT_NO_PATTERN, ...);
        if (accNo == null) return null;

        // Find account
        Account account = accountMgr.findAccount(accNo);
        if (account == null) {
            UIFormatter.printError("Account not found.");
            if (!confirmAction("Try again?")) return null;
            continue;
        }

        // CHECK ACCESS CONTROL
        if (currentUser.getUserRole() == UserRole.CUSTOMER) {
            // Customer can only view their own accounts
            UserAccount userAccount = (UserAccount) currentUser;
            String customerId = userAccount.getCustomerId();

            if (!account.getOwnerId().equals(customerId)) {
                UIFormatter.printError("Access denied. You can only view your own accounts.");
                if (!confirmAction("Try again?")) return null;
                continue;  // Retry
            }
        }

        // Admin or authorized customer - allow access
        return account;
    }
}
```

**Access Control Summary:**
- **Admin:** No restrictions, can view any account
- **Customer:** Must own the account (ownerId matches customerId)

#### Step 4: Business Logic - Polymorphic Data Retrieval

**Location:** `AccountManager.java:513-549`

```java
// Get account data
Customer owner = account.getOwner();
String accountNo = account.getAccountNo();
double balance = account.getBalance();

// Polymorphic instanceof check
boolean isSavings = account instanceof SavingsAccount;
boolean isChecking = account instanceof CheckingAccount;

// Type-specific data retrieval
if (isSavings) {
    SavingsAccount savings = (SavingsAccount) account;  // Downcast
    double interestRate = savings.getInterestRate();
} else if (isChecking) {
    CheckingAccount checking = (CheckingAccount) account;  // Downcast
    double overdraftLimit = checking.getOverdraftLimit();
    double availableCredit = checking.getBalance() + checking.getOverdraftLimit();
}
```

**Polymorphism Concepts:**
1. **instanceof:** Runtime type checking
2. **Downcasting:** Convert from superclass to subclass to access specific methods
3. **Dynamic binding:** Correct subclass methods called at runtime

#### Step 5: Data Updates

None - READ operation only.

#### Step 6: Feedback Display - Type-Specific Details

```java
UIFormatter.printTopBorder();
UIFormatter.printCenteredLine("ACCOUNT INFORMATION");
UIFormatter.printMiddleBorder();

// Common fields (all accounts)
UIFormatter.printLeftAlignedLine("  Account Number:     " + accountNo, 0);
UIFormatter.printLeftAlignedLine("  Account Type:       " +
    (isSavings ? "SAVINGS" : "CHECKING"), 0);
UIFormatter.printLeftAlignedLine("  Owner:              " +
    (owner != null ? owner.getName() : "NO OWNER"), 0);
UIFormatter.printLeftAlignedLine("  Current Balance:    $" +
    String.format("%.2f", balance), 0);

// POLYMORPHIC DISPLAY: Type-specific fields
if (account instanceof SavingsAccount) {
    SavingsAccount savings = (SavingsAccount) account;
    UIFormatter.printLeftAlignedLine("  Interest Rate:      " +
        String.format("%.2f%%", savings.getInterestRate() * 100), 0);
} else if (account instanceof CheckingAccount) {
    CheckingAccount checking = (CheckingAccount) account;
    UIFormatter.printLeftAlignedLine("  Overdraft Limit:    $" +
        String.format("%.2f", checking.getOverdraftLimit()), 0);
    UIFormatter.printLeftAlignedLine("  Available Credit:   $" +
        String.format("%.2f", checking.getBalance() + checking.getOverdraftLimit()), 0);
}

UIFormatter.printBottomBorder();
```

#### Step 7: Audit Logging

Not logged (read operation).

### 4. Code Snippets

**Access Control Method:**

**File:** `src/com/banking/BankingSystem.java:601-625`

```java
public boolean canAccessAccount(String accountNo) {
    if (currentUser == null) return false;

    // Admins can access all accounts
    if (currentUser.getUserRole() == UserRole.ADMIN) {
        return true;
    }

    // Customers can only access their own accounts
    if (currentUser.getUserRole() == UserRole.CUSTOMER) {
        Account account = accountManager.findAccount(accountNo);
        if (account == null) return false;

        UserAccount userAccount = (UserAccount) currentUser;
        return account.getOwnerId().equals(userAccount.getCustomerId());
    }

    return false;
}
```

**Polymorphic Display:**

```java
// instanceof runtime check
if (account instanceof SavingsAccount) {
    SavingsAccount savings = (SavingsAccount) account;
    System.out.println("Interest Rate: " + savings.getInterestRate());
} else if (account instanceof CheckingAccount) {
    CheckingAccount checking = (CheckingAccount) account;
    System.out.println("Overdraft Limit: " + checking.getOverdraftLimit());
}
```

### 5. Data Flow Diagram

```
User Input (Admin #6 or Customer #1)
    â”‚
    â”œâ”€â”€â†’ AccountManager.handleViewAccountDetails()
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ Get Account Number
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ Find Account in LinkedList<Account>
    â”‚         â”‚         â”‚
    â”‚         â”‚         â””â”€â”€â†’ accountMgr.findAccount(accNo)
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ ACCESS CONTROL CHECK
    â”‚         â”‚         â”‚
    â”‚         â”‚         â”œâ”€â”€â†’ If ADMIN: Allow all accounts
    â”‚         â”‚         â”‚
    â”‚         â”‚         â””â”€â”€â†’ If CUSTOMER: Check ownership
    â”‚         â”‚                   â”‚
    â”‚         â”‚                   â”œâ”€â”€â†’ account.getOwnerId() == user.getCustomerId()?
    â”‚         â”‚                   â”œâ”€â”€â†’ YES: Allow
    â”‚         â”‚                   â””â”€â”€â†’ NO: Deny (error, retry)
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ Extract common data (accountNo, balance, owner)
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ POLYMORPHISM: instanceof check
    â”‚         â”‚         â”‚
    â”‚         â”‚         â”œâ”€â”€â†’ if (account instanceof SavingsAccount):
    â”‚         â”‚         â”‚         â”‚
    â”‚         â”‚         â”‚         â””â”€â”€â†’ Downcast, get interestRate
    â”‚         â”‚         â”‚
    â”‚         â”‚         â””â”€â”€â†’ if (account instanceof CheckingAccount):
    â”‚         â”‚                   â”‚
    â”‚         â”‚                   â””â”€â”€â†’ Downcast, get overdraftLimit
    â”‚         â”‚
    â”‚         â””â”€â”€â†’ Display with type-specific details
    â”‚
    â””â”€â”€â†’ Return to menu
```

### 6. Example Usage

**Scenario 1: Admin Views Any Account (Savings)**

**Console Input:**
```
â†’ Account Number: ACC005
```

**Console Output:**
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘    ACCOUNT INFORMATION             â•‘
â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¢
  Account Number:     ACC005
  Account Type:       SAVINGS
  Owner:              Alice Johnson
  Owner ID:           C003
  Current Balance:    $1250.00
  Interest Rate:      1.50%
  Total Transactions: 5
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

**Scenario 2: Customer Views Own Account (Checking)**

**Console Input:**
```
â†’ Account Number: ACC006
```

**Console Output:**
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘    ACCOUNT INFORMATION             â•‘
â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¢
  Account Number:     ACC006
  Account Type:       CHECKING
  Owner:              Bob Smith
  Owner ID:           C004
  Current Balance:    $500.00
  Overdraft Limit:    $500.00
  Available Credit:   $1000.00
  Total Transactions: 3
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

**Scenario 3: Customer Tries to View Another Customer's Account (Access Denied)**

**Console Input:**
```
â†’ Account Number: ACC005
```

**Console Output:**
```
âœ— Access denied. You can only view your own accounts.
â†’ Try again? (yes/no): no
â„¹ Operation cancelled.
```

**Security:** Customer prevented from accessing other accounts.

---

## [Admin #7] View All Accounts

### 1. Menu Option Details

| Property | Value |
|----------|-------|
| **Admin Number** | 7 |
| **Customer Number** | N/A (Admin Only) |
| **Category** | ACCOUNT_OPERATIONS |
| **Display Name** | "View All Accounts" |
| **Handler Method** | `AccountManager.handleViewAllAccounts()` |
| **Source File** | `src/com/banking/managers/AccountManager.java:479-504` |
| **Access Control** | ADMIN only |
| **Required Permission** | VIEW_ALL_ACCOUNTS |

### 2. Purpose and Functionality

Displays a summary table of all accounts in the system.

**What it does:**
- Iterates through entire `LinkedList<Account>`
- Displays table with account number, type, owner, balance
- Uses **polymorphism** to determine type (instanceof)

### 3. Step-by-Step Code Flow

**Condensed Flow:**
1. Check if `accountList.isEmpty()`
2. Display table header
3. For each account in LinkedList:
   - Get accountNo, balance, owner
   - Use `instanceof` to determine type (Savings/Checking)
   - Display table row

### 4. Code Snippets

**File:** `src/com/banking/managers/AccountManager.java:479-504`

```java
public void handleViewAllAccounts() {
    UIFormatter.printSectionHeader("VIEW ALL ACCOUNTS");

    if (this.accountList.isEmpty()) {
        UIFormatter.printInfo("No accounts found.");
        return;
    }

    System.out.println("\nTotal Accounts: " + this.accountList.size());
    UIFormatter.printTableHeader("Account No", "Type", "Owner", "Balance");

    for (Account account : this.accountList) {  // LinkedList iteration
        String accountNo = account.getAccountNo();

        // Polymorphism: instanceof check
        String type = (account instanceof SavingsAccount) ? "Savings" : "Checking";

        String owner = (account.getOwner() != null) ?
                       account.getOwner().getName() : "N/A";
        String balance = "$" + String.format("%.2f", account.getBalance());

        UIFormatter.printTableRow(accountNo, type, owner, balance);
    }

    UIFormatter.printTableFooter();
}
```

### 5. Example Usage

**Console Output:**
```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   VIEW ALL ACCOUNTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Total Accounts: 4

â•”â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘Account No â”‚ Type     â”‚ Owner         â”‚ Balance   â•‘
â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¢
â•‘ ACC001    â”‚ Savings  â”‚ John Doe      â”‚ $1000.00  â•‘
â•‘ ACC002    â”‚ Checking â”‚ Jane Smith    â”‚ $2500.50  â•‘
â•‘ ACC003    â”‚ Savings  â”‚ Alice Johnson â”‚ $500.00   â•‘
â•‘ ACC004    â”‚ Checking â”‚ Bob Smith     â”‚ $1200.00  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## [Admin #8] Delete Account

### 1. Menu Option Details

| Property | Value |
|----------|-------|
| **Admin Number** | 8 |
| **Customer Number** | N/A (Admin Only) |
| **Category** | ACCOUNT_OPERATIONS |
| **Display Name** | "Delete Account" |
| **Handler Method** | `AccountManager.handleDeleteAccount()` |
| **Source File** | `src/com/banking/managers/AccountManager.java:551-607` |
| **Access Control** | ADMIN only |
| **Required Permission** | DELETE_ACCOUNT |

### 2. Purpose and Functionality

Deletes an account from the system with **balance validation** and **bidirectional cleanup**.

**What it does:**
- Prompts for account number with retry loop
- Shows account details before deletion
- **Validates zero balance** (security measure)
- Confirms action
- Removes from `LinkedList<Account>`
- Removes from customer's account list (bidirectional cleanup)
- Logs action

**Why use this:**
- Close inactive accounts
- Requires zero balance (prevents deleting accounts with money)
- Maintains referential integrity

### 3. Step-by-Step Code Flow

#### Step 3: Input Collection with Retry

```java
Account account = null;
while (account == null) {  // RETRY LOOP
    String accNo = validator.getValidatedInputWithFeedback(...);
    if (accNo == null) return;

    account = findAccount(accNo);
    if (account == null) {
        UIFormatter.printErrorEnhanced("Account does not exist", ...);
        if (!validator.confirmAction("Try again?")) return;
    }
}
```

#### Step 4: Business Logic - Balance Check & Confirmation

```java
// Show details
System.out.println("\nAccount to be deleted:");
UIFormatter.printDataRow("  Account Number:", account.getAccountNo());
UIFormatter.printDataRow("  Type:", account instanceof SavingsAccount ? "SAVINGS" : "CHECKING");
UIFormatter.printDataRow("  Balance:", "$" + String.format("%.2f", account.getBalance()));

// Validate zero balance
if (account.getBalance() != 0.0) {
    UIFormatter.printError("Cannot delete account with non-zero balance.");
    UIFormatter.printInfo("Please withdraw all funds first.");
    return;
}

// Confirm
if (!validator.confirmActionEnhanced("Are you sure?", null)) return;
```

#### Step 5: Data Updates - Bidirectional Cleanup

```java
public boolean deleteAccount(String accountNo) {
    Account account = findAccount(accountNo);
    if (account == null) return false;

    // Remove from system LinkedList
    this.accountList.remove(account);

    // Remove from customer's account list (bidirectional cleanup)
    Customer owner = account.getOwner();
    if (owner != null) {
        owner.removeAccount(accountNo);
    }

    UIFormatter.printSuccess("Account deleted: " + accountNo);
    return true;
}
```

### 4. Code Snippets

**Balance Validation:**
```java
if (account.getBalance() != 0.0) {
    UIFormatter.printError("Cannot delete account with non-zero balance.");
    UIFormatter.printInfo("Please withdraw all funds first.");
    return;
}
```

**Bidirectional Cleanup:**
```java
// Step 1: Remove from AccountManager's LinkedList
accountList.remove(account);

// Step 2: Remove from Customer's LinkedList
owner.removeAccount(accountNo);
```

### 5. Example Usage

**Scenario 1: Success - Zero Balance**

**Console Input/Output:**
```
â†’ Account Number: ACC007

Account to be deleted:
  Account Number: ACC007
  Type: SAVINGS
  Owner: Alice Johnson
  Balance: $0.00

â†’ Are you sure you want to delete this account? (yes/no): yes

âœ“ Account deleted successfully!
  Account Number: ACC007
  Status: Deleted
```

---

**Scenario 2: Error - Non-Zero Balance**

**Console Input/Output:**
```
â†’ Account Number: ACC005

Account to be deleted:
  Account Number: ACC005
  Type: SAVINGS
  Balance: $1250.00

âœ— Cannot delete account with non-zero balance.
â„¹ Please withdraw all funds first.
```

**Security:** Prevents deleting accounts with money (protects customer funds).

---

## [Admin #9] Update Overdraft Limit (Checking)

### 1. Menu Option Details

| Property | Value |
|----------|-------|
| **Admin Number** | 9 |
| **Customer Number** | N/A (Admin Only) |
| **Category** | ACCOUNT_OPERATIONS |
| **Display Name** | "Update Overdraft Limit (Checking)" |
| **Handler Method** | `AccountManager.handleUpdateOverdraftLimit()` |
| **Source File** | `src/com/banking/managers/AccountManager.java:609-651` (estimated) |
| **Access Control** | ADMIN only |
| **Required Permission** | UPDATE_OVERDRAFT_LIMIT |

### 2. Purpose and Functionality

Updates the overdraft limit for **Checking accounts only**.

**What it does:**
- Prompts for account number
- **Type check:** Validates account is CheckingAccount (not Savings)
- Displays current overdraft limit
- Prompts for new limit
- Updates overdraft limit
- Demonstrates **downcasting** and **type-specific operations**

**Why use this:**
- Adjust credit limits for checking accounts
- Risk management (increase/decrease overdraft)
- Demonstrates polymorphism (type-specific method only in CheckingAccount)

### 3. Step-by-Step Code Flow

#### Step 3: Input Collection & Type Validation

```java
UIFormatter.printSectionHeader("UPDATE OVERDRAFT LIMIT (CHECKING)");

// Get account
Account account = validator.getValidatedAccount(...);
if (account == null) return;

// TYPE CHECK: Must be CheckingAccount
if (!(account instanceof CheckingAccount)) {
    UIFormatter.printError("This account is not a Checking account.");
    UIFormatter.printInfo("Overdraft limits only apply to Checking accounts.");
    return;
}

// Downcast to access CheckingAccount-specific methods
CheckingAccount checking = (CheckingAccount) account;
```

#### Step 4: Business Logic - Update Overdraft

```java
// Display current limit
double currentLimit = checking.getOverdraftLimit();
UIFormatter.printInfo("Current overdraft limit: $" +
                      String.format("%.2f", currentLimit));

// Get new limit
Double newLimit = validator.getValidatedDouble("New overdraft limit:");
if (newLimit == null) return;

// Validate non-negative
if (newLimit < 0) {
    UIFormatter.printError("Overdraft limit cannot be negative.");
    return;
}

// Update
checking.setOverdraftLimit(newLimit);
UIFormatter.printSuccess("Overdraft limit updated to: $" +
                         String.format("%.2f", newLimit));
```

### 4. Code Snippets

**Type Check and Downcast:**
```java
// Runtime type check
if (!(account instanceof CheckingAccount)) {
    UIFormatter.printError("This is not a Checking account.");
    return;
}

// Downcast to subclass to access specific methods
CheckingAccount checking = (CheckingAccount) account;

// Now can access CheckingAccount-specific methods
checking.setOverdraftLimit(newLimit);
double limit = checking.getOverdraftLimit();
```

**CheckingAccount Class:**
```java
public class CheckingAccount extends Account {
    private double overdraftLimit;

    public double getOverdraftLimit() {
        return overdraftLimit;
    }

    public void setOverdraftLimit(double overdraftLimit) {
        if (overdraftLimit < 0) {
            throw new IllegalArgumentException("Overdraft limit cannot be negative");
        }
        this.overdraftLimit = overdraftLimit;
    }

    @Override
    public boolean withdraw(double amount) {
        // Can withdraw up to balance + overdraftLimit
        if (amount <= 0) return false;

        double availableCredit = this.balance + this.overdraftLimit;
        if (amount <= availableCredit) {
            this.balance -= amount;
            return true;
        }
        return false;  // Insufficient funds (including overdraft)
    }
}
```

### 5. Example Usage

**Scenario 1: Update Checking Account Overdraft**

**Console Input/Output:**
```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UPDATE OVERDRAFT LIMIT (CHECKING)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â†’ Account Number: ACC006

â„¹ Current overdraft limit: $500.00

â†’ New overdraft limit: 1000

âœ“ Overdraft limit updated to: $1000.00
  Account: ACC006
  Previous Limit: $500.00
  New Limit: $1000.00
```

---

**Scenario 2: Error - Savings Account (Wrong Type)**

**Console Input/Output:**
```
â†’ Account Number: ACC005

âœ— This account is not a Checking account.
â„¹ Overdraft limits only apply to Checking accounts.
```

**Polymorphism:** Savings accounts don't have overdraft limits, so operation is rejected.

---

## Summary

### Account Operations Recap

All 5 account operations demonstrate key OOP and polymorphism concepts:

| Operation | Admin # | Customer # | Polymorphism Demonstrated |
|-----------|---------|------------|---------------------------|
| Create Account | 5 | - | Runtime creation (new SavingsAccount/CheckingAccount) |
| View Account Details | 6 | 1 | instanceof checks, downcasting, type-specific display |
| View All Accounts | 7 | - | instanceof for type identification |
| Delete Account | 8 | - | Bidirectional relationship cleanup |
| Update Overdraft | 9 | - | Type checking, downcast, subclass-specific method |

### Polymorphism Patterns

1. **Runtime Type Creation:**
   ```java
   if (type.equals("SAVINGS")) {
       account = new SavingsAccount(...);
   } else {
       account = new CheckingAccount(...);
   }
   ```

2. **instanceof Type Checking:**
   ```java
   if (account instanceof SavingsAccount) {
       // Savings-specific logic
   } else if (account instanceof CheckingAccount) {
       // Checking-specific logic
   }
   ```

3. **Downcasting:**
   ```java
   CheckingAccount checking = (CheckingAccount) account;
   checking.setOverdraftLimit(1000);  // Subclass method
   ```

4. **Polymorphic Method Calls:**
   ```java
   account.getDetails();  // Calls SavingsAccount or CheckingAccount implementation
   ```

### Access Control Pattern

**Shared Operation (View Account Details):**
- **Menu:** Admin #6, Customer #1 (dual numbering)
- **Access Control:** Implemented at input validation layer
- **Logic:** Admins see all, customers see only their own

---

**â† Back to:** [Customer Operations](6.2-Customer-Ops.md) | **Up to:** [Menu Overview](6-Menu-Overview.md) | **Next:** [Transaction Operations â†’](6.4-Transaction-Ops.md)

