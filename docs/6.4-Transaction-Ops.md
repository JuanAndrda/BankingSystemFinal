# Banking System - Transaction Operations Documentation

**Project:** Banking Management System Final Project
**Courses:** CIT 207 & CC 204
**Document:** Transaction Operations (Shared: Admin & Customer)
**Date:** December 2025

---

## ğŸ“‘ Navigation

**â† Back to:** [Account Operations](6.3-Account-Ops.md) | **Up to:** [Menu Overview](6-Menu-Overview.md) | **Next:** [Profile & Reports â†’](6.5-Profile-Reports.md)

**Menu Documentation Index:**
- [6-Menu-Overview.md](6-Menu-Overview.md) - Architecture and summary tables
- [6.1-Login.md](6.1-Login.md) - Login Screen
- [6.2-Customer-Ops.md](6.2-Customer-Ops.md) - Customer Operations (Admin #1-4)
- [6.3-Account-Ops.md](6.3-Account-Ops.md) - Account Operations (Admin #5-9)
- **6.4-Transaction-Ops.md** - â† You are here
- [6.5-Profile-Reports.md](6.5-Profile-Reports.md) - Profile & Reports (Admin #14-19)
- [6.6-Security-Session.md](6.6-Security-Session.md) - Security & Session (Admin #21, #0, #20)

---

## Overview

This document covers **Transaction Operations** - the 4 most important banking operations, all **shared by both admins and customers**. These demonstrate **access control**, **polymorphism** (withdraw behavior), and **Stack-based data structures** (transaction history).

### Transaction Operations Summary

| Admin # | Customer # | Option Name | Handler | Access | Key Feature |
|---------|------------|-------------|---------|--------|-------------|
| **10** | **2** | Deposit Money | `TransactionProcessor.handleDeposit()` | Both (access-controlled) | Add money to account |
| **11** | **3** | Withdraw Money | `TransactionProcessor.handleWithdraw()` | Both (access-controlled) | Remove money (polymorphic withdraw) |
| **12** | **4** | Transfer Money | `TransactionProcessor.handleTransfer()` | Both (access-controlled) | Move money between accounts |
| **13** | **5** | View Transaction History | `TransactionProcessor.handleViewTransactionHistory()` | Both (access-controlled) | Display history (Stack LIFO) |

**Category:** TRANSACTION_OPERATIONS
**All operations are SHARED:** Admins and customers both have access
**Access Control:** Customers can only transact on their own accounts

---

## [Admin #10 / Customer #2] Deposit Money

### 1. Menu Option Details

| Property | Value |
|----------|-------|
| **Admin Number** | 10 |
| **Customer Number** | 2 |
| **Category** | TRANSACTION_OPERATIONS |
| **Display Name** | "Deposit Money" |
| **Handler Method** | `TransactionProcessor.handleDeposit()` |
| **Source File** | `src/com/banking/managers/TransactionProcessor.java:123-169` |
| **Access Control** | Both roles (access-controlled) |
| **Required Permission** | DEPOSIT_MONEY |

**Dual Numbering:**
```java
DEPOSIT_MONEY("Deposit Money", 10, 2, null, MenuCategory.TRANSACTION_OPERATIONS)
//                              â†‘   â†‘   â†‘
//                         Admin Cust Both
```

### 2. Purpose and Functionality

Adds money to a bank account with full validation and audit logging.

**What it does:**
- Prompts for account number
- **Access Control:** Customers can only deposit to their own accounts
- Prompts for deposit amount (validates positive, non-zero)
- Creates `Transaction` object
- Calls `account.deposit(amount)` to update balance
- Adds transaction to account's `LinkedList<Transaction>`
- Logs to audit trail (`Stack<AuditLog>`)

**Why use this:**
- Add funds to account
- Most common banking operation
- Demonstrates access control for shared operations
- Shows transaction tracking

### 3. Step-by-Step Code Flow

#### Step 1: Menu Selection
- Admin selects #10 â†’ `DEPOSIT_MONEY`
- Customer selects #2 â†’ `DEPOSIT_MONEY`
- **Same handler, different numbers**

#### Step 2: Permission Check
Both roles allowed (null in MenuAction), but access control enforced at handler level.

#### Step 3: Input Collection - Account Number with Access Control

**Location:** `TransactionProcessor.java:123-145`

```java
UIFormatter.printSectionHeader("DEPOSIT MONEY");

while (true) {  // RETRY LOOP
    // Get account
    Account account = this.validator.getValidatedAccountWithLabel(
        "Account to deposit to:",
        "âœ— Account not found. Cannot deposit to non-existent account.");
    if (account == null) return;

    // ACCESS CONTROL CHECK
    if (!this.bankingSystem.canAccessAccount(account.getAccountNo())) {
        UIFormatter.printErrorEnhanced(
            "Access denied. You can only perform transactions on your own accounts.",
            "Please select one of your accounts from the list above.");

        // Log access denial
        this.bankingSystem.logAction("ACCESS_DENIED",
            "Attempted to deposit to account: " + account.getAccountNo());

        if (!this.validator.confirmAction("Try again with a different account?")) {
            return;
        }
        continue;  // Retry
    }

    // Access granted - continue...
}
```

**Access Control Logic:**

**File:** `BankingSystem.java:601-625`

```java
public boolean canAccessAccount(String accountNo) {
    if (currentUser == null) return false;

    // ADMIN: Can access all accounts
    if (currentUser.getUserRole() == UserRole.ADMIN) {
        return true;
    }

    // CUSTOMER: Can only access own accounts
    if (currentUser.getUserRole() == UserRole.CUSTOMER) {
        Account account = accountManager.findAccount(accountNo);
        if (account == null) return false;

        UserAccount userAccount = (UserAccount) currentUser;
        return account.getOwner().getCustomerId().equals(userAccount.getCustomerId());
    }

    return false;
}
```

#### Step 4: Business Logic - Create Transaction & Deposit

**Location:** `TransactionProcessor.java:147-159`

```java
// Get amount
Double depAmt = this.validator.getValidatedAmountWithLabel("Amount to deposit:");
if (depAmt == null) return;

// Perform deposit
boolean success = this.deposit(account.getAccountNo(), depAmt);

if (success) {
    UIFormatter.printSuccessEnhanced(
        "Deposit successful!",
        "Amount: $" + String.format("%.2f", depAmt),
        "Account: " + account.getAccountNo(),
        "New Balance: $" + String.format("%.2f", account.getBalance()));

    InputValidator.safeLogAction(bankingSystem, "DEPOSIT",
        "Amount: $" + depAmt + " to account: " + account.getAccountNo());
    break;
}
```

**Core Deposit Method:**

**File:** `TransactionProcessor.java:36-59`

```java
public boolean deposit(String accountNo, double amount) {
    Account account = AccountUtils.findAccount(this.accountList, accountNo);
    if (account == null) {
        UIFormatter.printError("Account not found: " + accountNo);
        return false;
    }

    try {
        // Create transaction record
        Transaction tx = new Transaction(
            "TX" + String.format("%03d", this.txCounter++),  // TX001, TX002...
            TransactionType.DEPOSIT,
            amount
        );
        tx.setToAccountNo(accountNo);

        // Update account balance
        account.deposit(amount);  // Encapsulated in Account class

        // Mark transaction as completed
        tx.setStatus("COMPLETED");

        // Add to account's transaction history
        account.addTransaction(tx);

        UIFormatter.printSuccess("Deposit processed: " + tx.getTxId());
        return true;

    } catch (IllegalArgumentException e) {
        UIFormatter.printError("Error processing deposit: " + e.getMessage());
        return false;
    }
}
```

#### Step 5: Data Updates - Multiple Data Structures

```java
// 1. Update account balance (encapsulated)
account.deposit(amount);  // this.balance += amount

// 2. Add transaction to LinkedList<Transaction> in Account
account.addTransaction(tx);  // transactionHistory.add(tx)

// 3. Log to Stack<AuditLog> in AuthenticationManager
auditTrail.push(new AuditLog(...));  // LIFO
```

**Data Structures Updated:**
1. `Account.balance` - increased by deposit amount
2. `LinkedList<Transaction>` in Account - transaction added
3. `Stack<AuditLog>` in AuthenticationManager - audit log pushed

#### Step 6: Feedback Display

Success message displayed in Step 4 with:
- Amount deposited
- Account number
- New balance
- Transaction ID (in success method)

#### Step 7: Audit Logging

```java
auditTrail.push(new AuditLog(
    LocalDateTime.now(),
    currentUser.getUsername(),
    currentUser.getUserRole(),
    "DEPOSIT",
    "Amount: $500.00 to account: ACC005"
));
```

### 4. Code Snippets

**MenuAction Enum:**
```java
DEPOSIT_MONEY("Deposit Money", 10, 2, null, MenuCategory.TRANSACTION_OPERATIONS)
```

**Full Deposit Flow:**

**File:** `src/com/banking/managers/TransactionProcessor.java:36-59`

```java
public boolean deposit(String accountNo, double amount) {
    Account account = AccountUtils.findAccount(this.accountList, accountNo);
    if (account == null) return false;

    try {
        // Create transaction
        Transaction tx = new Transaction(
            "TX" + String.format("%03d", this.txCounter++),
            TransactionType.DEPOSIT,
            amount
        );
        tx.setToAccountNo(accountNo);

        // Update balance
        account.deposit(amount);  // this.balance += amount

        // Mark completed
        tx.setStatus("COMPLETED");

        // Add to history
        account.addTransaction(tx);  // LinkedList.add()

        UIFormatter.printSuccess("Deposit processed: " + tx.getTxId());
        return true;

    } catch (IllegalArgumentException e) {
        UIFormatter.printError("Error: " + e.getMessage());
        return false;
    }
}
```

**Account.deposit() Method:**
```java
// Account.java
public void deposit(double amount) {
    if (amount <= 0) {
        throw new IllegalArgumentException("Deposit amount must be positive");
    }
    this.balance += amount;
}
```

### 5. Data Flow Diagram

```
User Input (Admin #10 or Customer #2)
    â”‚
    â”œâ”€â”€â†’ TransactionProcessor.handleDeposit()
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ Get Account Number
    â”‚         â”‚         â”‚
    â”‚         â”‚         â””â”€â”€â†’ Find in LinkedList<Account>
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ ACCESS CONTROL: canAccessAccount()?
    â”‚         â”‚         â”‚
    â”‚         â”‚         â”œâ”€â”€â†’ Admin: TRUE (all accounts)
    â”‚         â”‚         â””â”€â”€â†’ Customer: Check ownership
    â”‚         â”‚                   â”‚
    â”‚         â”‚                   â””â”€â”€â†’ account.ownerId == user.customerId?
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ Get Amount (validated positive, non-zero)
    â”‚         â”‚
    â”‚         â””â”€â”€â†’ deposit(accountNo, amount)
    â”‚                   â”‚
    â”‚                   â”œâ”€â”€â†’ new Transaction(TX001, DEPOSIT, amount)
    â”‚                   â”‚
    â”‚                   â”œâ”€â”€â†’ account.deposit(amount)
    â”‚                   â”‚         â”‚
    â”‚                   â”‚         â””â”€â”€â†’ balance += amount
    â”‚                   â”‚
    â”‚                   â”œâ”€â”€â†’ account.addTransaction(tx)
    â”‚                   â”‚         â”‚
    â”‚                   â”‚         â””â”€â”€â†’ LinkedList<Transaction>.add(tx)
    â”‚                   â”‚
    â”‚                   â””â”€â”€â†’ Display success
    â”‚
    â”œâ”€â”€â†’ Log to Stack<AuditLog>
    â”‚         â”‚
    â”‚         â””â”€â”€â†’ auditTrail.push(log)
    â”‚
    â””â”€â”€â†’ Return to menu
```

### 6. Example Usage

**Scenario 1: Customer Deposits to Own Account**

**Console Input/Output:**
```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DEPOSIT MONEY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â†’ Account to deposit to: ACC005
âœ“ Account found: ACC005 (Alice Johnson)

â†’ Amount to deposit: 500

âœ“ Deposit processed: TX012

âœ“ Deposit successful!
  Amount: $500.00
  Account: ACC005
  New Balance: $1750.00
```

**Data Before:**
```java
Account ACC005:
  balance = 1250.00
  transactionHistory.size() = 11
```

**Data After:**
```java
Account ACC005:
  balance = 1750.00  // +500
  transactionHistory.size() = 12  // New transaction added

Transaction TX012:
  type = DEPOSIT
  amount = 500.00
  status = "COMPLETED"
  toAccountNo = "ACC005"

auditTrail (Stack):
  AuditLog{action='DEPOSIT', details='Amount: $500.00 to account: ACC005'}
```

---

**Scenario 2: Customer Tries to Deposit to Another's Account (Access Denied)**

**Console Input/Output:**
```
â†’ Account to deposit to: ACC001

âœ— Access denied. You can only perform transactions on your own accounts.
  Please select one of your accounts from the list above.

â†’ Try again with a different account? (yes/no): no
â„¹ Operation cancelled.
```

**Security:** Access control prevents unauthorized deposits.

---

## [Admin #11 / Customer #3] Withdraw Money

### 1. Menu Option Details

| Property | Value |
|----------|-------|
| **Admin Number** | 11 |
| **Customer Number** | 3 |
| **Category** | TRANSACTION_OPERATIONS |
| **Display Name** | "Withdraw Money" |
| **Handler Method** | `TransactionProcessor.handleWithdraw()` |
| **Source File** | `src/com/banking/managers/TransactionProcessor.java:171-217` |
| **Access Control** | Both roles (access-controlled) |
| **Required Permission** | WITHDRAW_MONEY |

### 2. Purpose and Functionality

Removes money from a bank account with **polymorphic withdraw** behavior (Savings vs Checking).

**What it does:**
- Prompts for account number (with access control)
- Prompts for withdrawal amount
- Creates `Transaction` object
- Calls **polymorphic** `account.withdraw(amount)`
  - **SavingsAccount:** Simple balance check
  - **CheckingAccount:** Balance + overdraft limit check
- Updates balance
- Adds transaction to history
- Logs to audit trail

**Why use this:**
- Remove funds from account
- Demonstrates **runtime polymorphism** (different withdraw logic per account type)
- Shows overdraft feature for Checking accounts

**Polymorphism:** Same `withdraw()` method call behaves differently based on account type.

### 3. Step-by-Step Code Flow

#### Steps 1-3: Menu Selection, Permission, Input Collection
Same as Deposit (access-controlled account selection).

#### Step 4: Business Logic - Polymorphic Withdraw

**Location:** `TransactionProcessor.java:195-215`

```java
Double witAmt = this.validator.getValidatedAmountWithLabel("Amount to withdraw:");
if (witAmt == null) return;

boolean success = this.withdraw(account.getAccountNo(), witAmt);

if (success) {
    UIFormatter.printSuccessEnhanced(
        "Withdrawal successful!",
        "Amount: $" + String.format("%.2f", witAmt),
        "Account: " + account.getAccountNo(),
        "New Balance: $" + String.format("%.2f", account.getBalance()));
}
```

**Core Withdraw Method:**

**File:** `TransactionProcessor.java:61-72`

```java
public boolean withdraw(String accountNo, double amount) {
    Account account = AccountUtils.findAccount(this.accountList, accountNo);
    if (account == null) return false;

    try {
        Transaction tx = new Transaction(
            "TX" + String.format("%03d", this.txCounter++),
            TransactionType.WITHDRAW,
            amount
        );
        tx.setFromAccountNo(accountNo);

        // POLYMORPHIC CALL: Different behavior per account type
        if (account.withdraw(amount)) {
            tx.setStatus("COMPLETED");
            account.addTransaction(tx);
            UIFormatter.printSuccess("Withdrawal processed: " + tx.getTxId());
            return true;
        } else {
            tx.setStatus("FAILED");
            account.addTransaction(tx);
            UIFormatter.printError("Insufficient funds or withdrawal failed");
            return false;
        }

    } catch (IllegalArgumentException e) {
        UIFormatter.printError("Error: " + e.getMessage());
        return false;
    }
}
```

**Polymorphic Withdraw Implementations:**

**SavingsAccount:**
```java
@Override
public boolean withdraw(double amount) {
    if (amount <= 0) return false;

    // Simple balance check - no overdraft
    if (amount <= this.balance) {
        this.balance -= amount;
        return true;
    }

    return false;  // Insufficient funds
}
```

**CheckingAccount:**
```java
@Override
public boolean withdraw(double amount) {
    if (amount <= 0) return false;

    // Can withdraw up to balance + overdraft limit
    double availableCredit = this.balance + this.overdraftLimit;

    if (amount <= availableCredit) {
        this.balance -= amount;  // Balance can go negative
        return true;
    }

    return false;  // Exceeds available credit
}
```

**Polymorphism in Action:**

```java
// Compile-time: Type is Account
Account account = findAccount(accountNo);

// Runtime: Could be SavingsAccount or CheckingAccount
boolean success = account.withdraw(500);
//                         â†‘
//               Calls SavingsAccount.withdraw()
//               OR CheckingAccount.withdraw()
//               depending on actual object type
```

### 4. Code Snippets

**Polymorphic Behavior Example:**

```java
// Scenario 1: SavingsAccount with $1000 balance
SavingsAccount savings = new SavingsAccount(...);
savings.deposit(1000);
savings.withdraw(1200);  // Returns FALSE - insufficient funds

// Scenario 2: CheckingAccount with $1000 balance, $500 overdraft
CheckingAccount checking = new CheckingAccount(...);
checking.deposit(1000);
checking.withdraw(1200);  // Returns TRUE - uses overdraft
// New balance: -$200 (negative, but within overdraft limit)
```

### 5. Data Flow Diagram

```
User Input (Admin #11 or Customer #3)
    â”‚
    â”œâ”€â”€â†’ TransactionProcessor.handleWithdraw()
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ Get Account (access-controlled)
    â”‚         â”‚
    â”‚         â”œâ”€â”€â†’ Get Amount
    â”‚         â”‚
    â”‚         â””â”€â”€â†’ withdraw(accountNo, amount)
    â”‚                   â”‚
    â”‚                   â”œâ”€â”€â†’ new Transaction(TX013, WITHDRAW, amount)
    â”‚                   â”‚
    â”‚                   â”œâ”€â”€â†’ POLYMORPHIC CALL: account.withdraw(amount)
    â”‚                   â”‚         â”‚
    â”‚                   â”‚         â”œâ”€â”€â†’ SavingsAccount.withdraw():
    â”‚                   â”‚         â”‚         â”‚
    â”‚                   â”‚         â”‚         â””â”€â”€â†’ Check: amount <= balance?
    â”‚                   â”‚         â”‚
    â”‚                   â”‚         â””â”€â”€â†’ CheckingAccount.withdraw():
    â”‚                   â”‚                   â”‚
    â”‚                   â”‚                   â””â”€â”€â†’ Check: amount <= (balance + overdraft)?
    â”‚                   â”‚
    â”‚                   â”œâ”€â”€â†’ If successful:
    â”‚                   â”‚     tx.status = "COMPLETED"
    â”‚                   â”‚     account.addTransaction(tx)
    â”‚                   â”‚
    â”‚                   â””â”€â”€â†’ If failed:
    â”‚                         tx.status = "FAILED"
    â”‚                         account.addTransaction(tx)  // Still recorded!
    â”‚
    â””â”€â”€â†’ Log to audit trail
```

### 6. Example Usage

**Scenario 1: Successful Withdrawal from Savings Account**

**Console Input/Output:**
```
â†’ Account to withdraw from: ACC005 (Savings)
â†’ Amount to withdraw: 500

âœ“ Withdrawal processed: TX013

âœ“ Withdrawal successful!
  Amount: $500.00
  Account: ACC005
  New Balance: $1250.00
```

---

**Scenario 2: Overdraft Withdrawal from Checking Account**

**Console Input/Output:**
```
â†’ Account to withdraw from: ACC006 (Checking, $500 balance, $500 overdraft)
â†’ Amount to withdraw: 700

âœ“ Withdrawal processed: TX014

âœ“ Withdrawal successful!
  Amount: $700.00
  Account: ACC006
  New Balance: $-200.00  â† Negative balance (within overdraft)
```

**Polymorphism:** CheckingAccount allowed withdrawal because:
```
available = balance + overdraft = 500 + 500 = 1000
withdraw = 700
700 <= 1000 â†’ SUCCESS
New balance = 500 - 700 = -200
```

---

**Scenario 3: Insufficient Funds (Savings)**

**Console Input/Output:**
```
â†’ Account to withdraw from: ACC005 (Savings, $100 balance)
â†’ Amount to withdraw: 500

âœ— Insufficient funds or withdrawal failed

âœ— Withdrawal failed.
â†’ Try again? (yes/no): no
```

**Failed Transaction Still Recorded:**
```java
Transaction TX015:
  type = WITHDRAW
  amount = 500.00
  status = "FAILED"  â† Marked as failed
  fromAccountNo = "ACC005"
```

**Audit Trail:** Failed attempts are logged for security monitoring.

---

## [Admin #12 / Customer #4] Transfer Money

### 1. Menu Option Details

| Property | Value |
|----------|-------|
| **Admin Number** | 12 |
| **Customer Number** | 4 |
| **Category** | TRANSACTION_OPERATIONS |
| **Display Name** | "Transfer Money" |
| **Handler Method** | `TransactionProcessor.handleTransfer()` |
| **Source File** | `src/com/banking/managers/TransactionProcessor.java:219-280` |
| **Access Control** | Both roles (access-controlled) |
| **Required Permission** | TRANSFER_MONEY |

### 2. Purpose and Functionality

Moves money from one account to another with atomic transaction behavior.

**What it does:**
- Prompts for source account (with access control)
- Prompts for destination account
- Validates different accounts (can't transfer to same account)
- Prompts for amount
- **Atomic operation:** Withdraw from source, deposit to destination
- Creates single Transaction record linked to both accounts
- Adds transaction to both accounts' histories
- Logs to audit trail

**Why use this:**
- Move money between accounts
- Demonstrates multi-step atomic operations
- Shows transaction linking (one transaction, two accounts)

### 3. Step-by-Step Code Flow

#### Step 3: Input Collection - Two Accounts + Amount

**Location:** `TransactionProcessor.java:219-258`

```java
while (true) {
    // Get source account (access-controlled)
    Account fromAccount = this.validator.getValidatedAccountWithLabel(
        "Account to transfer FROM:",
        "âœ— Account not found.");
    if (fromAccount == null) return;

    // ACCESS CONTROL: Customer can only transfer from own accounts
    if (!this.bankingSystem.canAccessAccount(fromAccount.getAccountNo())) {
        UIFormatter.printErrorEnhanced(
            "Access denied. You can only transfer FROM your own accounts.",
            "Please select one of your accounts.");

        this.bankingSystem.logAction("ACCESS_DENIED",
            "Attempted to transfer from account: " + fromAccount.getAccountNo());

        if (!this.validator.confirmAction("Try again?")) return;
        continue;
    }

    // Get destination account
    Account toAccount = this.validator.getValidatedAccountWithLabel(
        "Destination account (to transfer TO):",
        "âœ— Destination account not found.");
    if (toAccount == null) return;

    // Validate different accounts
    if (fromAccount.getAccountNo().equals(toAccount.getAccountNo())) {
        UIFormatter.printError("Cannot transfer to the same account");
        if (!this.validator.confirmAction("Try again?")) return;
        continue;
    }

    // Get amount
    Double amt = this.validator.getValidatedAmountWithLabel("Amount to transfer:");
    if (amt == null) return;

    // Perform transfer...
}
```

#### Step 4: Business Logic - Atomic Transfer

**File:** `TransactionProcessor.java:74-106`

```java
public boolean transfer(String fromAccountNo, String toAccountNo, double amount) {
    Account fromAccount = AccountUtils.findAccount(this.accountList, fromAccountNo);
    Account toAccount = AccountUtils.findAccount(this.accountList, toAccountNo);

    if (fromAccount == null || toAccount == null) {
        UIFormatter.printError("One or both accounts not found");
        return false;
    }

    try {
        // Create transaction
        Transaction tx = new Transaction(
            "TX" + String.format("%03d", this.txCounter++),
            TransactionType.TRANSFER,
            amount
        );
        tx.setFromAccountNo(fromAccountNo);
        tx.setToAccountNo(toAccountNo);

        // ATOMIC OPERATION: Withdraw then deposit
        if (fromAccount.withdraw(amount)) {  // Polymorphic
            toAccount.deposit(amount);

            // Mark completed
            tx.setStatus("COMPLETED");

            // Add to BOTH accounts' histories
            fromAccount.addTransaction(tx);
            toAccount.addTransaction(tx);

            UIFormatter.printSuccess("Transfer processed: " + tx.getTxId());
            return true;

        } else {
            // Withdrawal failed - don't deposit
            tx.setStatus("FAILED");
            fromAccount.addTransaction(tx);  // Record failure
            UIFormatter.printError("Transfer failed: Insufficient funds");
            return false;
        }

    } catch (IllegalArgumentException e) {
        UIFormatter.printError("Error: " + e.getMessage());
        return false;
    }
}
```

**Atomic Behavior:**
1. Try to withdraw from source
2. **If successful:** Deposit to destination
3. **If failed:** Don't deposit (money not created out of thin air)
4. Record transaction in both accounts

### 4. Code Snippets

**Atomic Transfer Logic:**
```java
// Step 1: Withdraw from source (can fail)
if (fromAccount.withdraw(amount)) {

    // Step 2: Deposit to destination (always succeeds if withdraw succeeded)
    toAccount.deposit(amount);

    // Step 3: Mark completed and record in BOTH accounts
    tx.setStatus("COMPLETED");
    fromAccount.addTransaction(tx);
    toAccount.addTransaction(tx);

    return true;
} else {
    // Withdraw failed - transaction aborted
    tx.setStatus("FAILED");
    fromAccount.addTransaction(tx);  // Record failure
    return false;
}
```

### 5. Example Usage

**Scenario: Transfer Between Accounts**

**Console Input/Output:**
```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TRANSFER MONEY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â†’ Account to transfer FROM: ACC005
â†’ Destination account (to transfer TO): ACC006
â†’ Amount to transfer: 300

âœ“ Transfer processed: TX016

âœ“ Transfer successful!
  Amount: $300.00
  From: ACC005
  To: ACC006
  New Balance (From): $1450.00
```

**Data Before:**
```java
ACC005 (Savings): balance = 1750.00
ACC006 (Checking): balance = 500.00
```

**Data After:**
```java
ACC005: balance = 1450.00  // -300
ACC006: balance = 800.00   // +300

Transaction TX016:
  type = TRANSFER
  amount = 300.00
  fromAccountNo = "ACC005"
  toAccountNo = "ACC006"
  status = "COMPLETED"

ACC005.transactionHistory contains TX016
ACC006.transactionHistory contains TX016  â† Same transaction in both!
```

---

## [Admin #13 / Customer #5] View Transaction History

### 1. Menu Option Details

| Property | Value |
|----------|-------|
| **Admin Number** | 13 |
| **Customer Number** | 5 |
| **Category** | TRANSACTION_OPERATIONS |
| **Display Name** | "View Transaction History" |
| **Handler Method** | `TransactionProcessor.handleViewTransactionHistory()` |
| **Source File** | `src/com/banking/managers/TransactionProcessor.java:282-330` |
| **Access Control** | Both roles (access-controlled) |
| **Required Permission** | VIEW_TRANSACTION_HISTORY |

### 2. Purpose and Functionality

Displays transaction history for an account using **Stack data structure** for LIFO display (most recent first).

**What it does:**
- Prompts for account number (access-controlled)
- Retrieves account's `LinkedList<Transaction>`
- **Converts to Stack** for LIFO display
- Displays transactions in reverse chronological order (newest first)
- Shows transaction ID, type, amount, status

**Why use this:**
- Review account activity
- Audit transactions
- Demonstrates **Stack data structure** (LIFO)
- Shows data structure conversion (LinkedList â†’ Stack)

**Data Structure:** Stack used for LIFO display (industry standard - newest transactions shown first).

### 3. Step-by-Step Code Flow

#### Step 3: Input Collection
Access-controlled account selection (same as other operations).

#### Step 4: Business Logic - LinkedList to Stack Conversion

**Location:** `TransactionProcessor.java:303-329`

```java
// Get transactions as Stack (LIFO)
Stack<Transaction> txStack = this.getAccountTransactionsAsStack(account.getAccountNo());

if (txStack.isEmpty()) {
    UIFormatter.printInfo("No transactions yet.");
    return;
}

System.out.println("\n=== TRANSACTION HISTORY (LIFO - Most Recent First) ===");
System.out.println("Account: " + account.getAccountNo());
System.out.println("Total Transactions: " + txStack.size());

UIFormatter.printTableHeader("TX ID", "Type", "Amount", "Status");

// Pop from stack (LIFO - newest first)
while (!txStack.isEmpty()) {
    Transaction tx = txStack.pop();  // O(1) operation
    String txId = tx.getTxId();
    String type = tx.getType().toString();
    String amount = "$" + String.format("%.2f", tx.getAmount());
    String status = tx.getStatus();

    UIFormatter.printTableRow(txId, type, amount, status);
}

UIFormatter.printTableFooter();
```

**LinkedList to Stack Conversion:**

**File:** `TransactionProcessor.java:108-121`

```java
public Stack<Transaction> getAccountTransactionsAsStack(String accountNo) {
    Account acc = AccountUtils.findAccount(this.accountList, accountNo);
    if (acc == null) return new Stack<>();

    Stack<Transaction> txStack = new Stack<>();
    LinkedList<Transaction> history = acc.getTransactionHistory();

    // Push all transactions to stack
    for (Transaction tx : history) {
        txStack.push(tx);  // O(1) per push
    }

    return txStack;
}
```

**Algorithm:**
1. **Input:** LinkedList<Transaction> in insertion order (oldest first)
2. **Process:** Push each transaction to Stack
3. **Output:** Stack in LIFO order (newest first when popped)

**Time Complexity:** O(n) where n = number of transactions

**Why Stack?**
- LIFO display matches user expectations (most recent first)
- Matches industry standard (banking apps show recent transactions first)
- Efficient O(1) push/pop operations
- Consistent with audit trail display

### 4. Code Snippets

**Stack Operations:**
```java
// Create stack
Stack<Transaction> txStack = new Stack<>();

// Push all transactions (from LinkedList)
for (Transaction tx : history) {
    txStack.push(tx);  // LIFO - last pushed is first popped
}

// Pop and display (LIFO order)
while (!txStack.isEmpty()) {
    Transaction tx = txStack.pop();  // Most recent first
    System.out.println(tx);
}
```

**Data Structure Comparison:**

```java
// LinkedList order (insertion order - oldest first):
[TX001, TX002, TX003, TX004, TX005]
 â†‘ oldest                   newest â†‘

// After pushing to Stack:
Stack top â†’ [TX005, TX004, TX003, TX002, TX001] â† Stack bottom

// Pop order (LIFO - newest first):
TX005 (most recent)
TX004
TX003
TX002
TX001 (oldest)
```

### 5. Example Usage

**Scenario: View Transaction History**

**Console Input:**
```
â†’ Account Number: ACC005
```

**Console Output:**
```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   VIEW TRANSACTION HISTORY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

=== TRANSACTION HISTORY (LIFO - Most Recent First) ===
Account: ACC005
Total Transactions: 5

â•”â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ TX ID â”‚ Type     â”‚ Amount    â”‚ Status    â•‘
â•Ÿâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¢
â•‘ TX016 â”‚ TRANSFER â”‚ $300.00   â”‚ COMPLETED â•‘  â† Most recent
â•‘ TX013 â”‚ WITHDRAW â”‚ $500.00   â”‚ COMPLETED â•‘
â•‘ TX012 â”‚ DEPOSIT  â”‚ $500.00   â”‚ COMPLETED â•‘
â•‘ TX008 â”‚ DEPOSIT  â”‚ $1000.00  â”‚ COMPLETED â•‘
â•‘ TX005 â”‚ DEPOSIT  â”‚ $250.00   â”‚ COMPLETED â•‘  â† Oldest
â•šâ•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•
```

**Data Flow:**

```java
// Step 1: Get LinkedList from Account
LinkedList<Transaction> history = account.getTransactionHistory();
// [TX005, TX008, TX012, TX013, TX016]  â† Insertion order

// Step 2: Convert to Stack
Stack<Transaction> txStack = new Stack<>();
for (Transaction tx : history) {
    txStack.push(tx);
}
// Stack: [TX016, TX013, TX012, TX008, TX005]  â† LIFO

// Step 3: Pop and display
while (!txStack.isEmpty()) {
    Transaction tx = txStack.pop();  // TX016, TX013, TX012...
    print(tx);
}
```

---

## Summary

### Transaction Operations Recap

All 4 transaction operations demonstrate key concepts:

| Operation | Admin # | Cust # | Key Concept |
|-----------|---------|--------|-------------|
| Deposit Money | 10 | 2 | Access control, transaction tracking |
| Withdraw Money | 11 | 3 | **Polymorphism** (Savings vs Checking withdraw) |
| Transfer Money | 12 | 4 | **Atomic operations**, dual transaction linking |
| View History | 13 | 5 | **Stack data structure** (LIFO display) |

### Access Control Pattern

**All operations are shared but access-controlled:**

```java
// Admin: Can access ANY account
if (currentUser.getUserRole() == UserRole.ADMIN) {
    return true;
}

// Customer: Can only access OWN accounts
if (currentUser.getUserRole() == UserRole.CUSTOMER) {
    return account.getOwner().getCustomerId().equals(userAccount.getCustomerId());
}
```

### Data Structures Used

1. **LinkedList<Transaction>** - Stores transactions in insertion order
2. **Stack<Transaction>** - LIFO display (most recent first)
3. **Stack<AuditLog>** - Audit trail logging (most recent first)

### Polymorphism Example

**Withdraw Method:**
```java
// Compile-time: Type is Account
Account account = findAccount(accNo);

// Runtime: Could be SavingsAccount or CheckingAccount
boolean success = account.withdraw(amount);
//                         â†‘
//               Different behavior based on actual type:
//               - SavingsAccount: balance check only
//               - CheckingAccount: balance + overdraft check
```

### Transaction States

All transactions have a status:
- **"COMPLETED"** - Successful
- **"FAILED"** - Insufficient funds or validation error
- Failed transactions are still recorded for audit purposes

---

**â† Back to:** [Account Operations](6.3-Account-Ops.md) | **Up to:** [Menu Overview](6-Menu-Overview.md) | **Next:** [Profile & Reports â†’](6.5-Profile-Reports.md)

